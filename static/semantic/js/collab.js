// Generated by CoffeeScript 1.6.2
/*
# SocketEvent class #
Socket Event class is a class that does all conversions and packing of events send by sockets and channels
*/


(function() {
  var _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Batman.SocketEvent = (function() {
    /*
    Socket Event class is a class that does all conversions and packing of events send by sockets and channels
    it contains a lot of useful static helpers to generate events that needed
    */
    function SocketEvent(content, channel, request, room) {
      this.content = content;
      this.channel = channel;
      this.request = request != null ? request : "push";
      this.room = room != null ? room : "all";
      /*
        creates websocket event where
        content is inside content variable, channel is for source (model) or type of content
        request is for what you want to do with content
        room is for what users to you want to spread this info
      */

      if (!((this.content.id != null) || this.content.query)) {
        this.content.id = SocketEvent.genId();
      }
    }

    SocketEvent.makeEvent = function(content, channel, req, room) {
      if (room == null) {
        room = "all";
      }
      /*
        creates a socketevent, where:
        content is content of event
        channel is name of the channel that is used for this event
        req is a request with what this event is send
        room is an info to which users should the event be sent to
      */

      return new Batman.SocketEvent(content, channel, req, room);
    };

    SocketEvent.makeQueryEvent = function(query, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        query: query
      }, channel, "read", room);
    };

    SocketEvent.makeLookupEvent = function(lField, lQuery, channel, room) {
      var content;

      if (room == null) {
        room = "me";
      }
      content = {
        field: lField,
        query: lQuery
      };
      return Batman.SocketEvent.makeEvent(content, channel, "lookup", room);
    };

    SocketEvent.makePushEvent = function(content, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent(content, channel, "push", room);
    };

    SocketEvent.makeReadEvent = function(id, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        id: id
      }, channel, "read", room);
    };

    SocketEvent.makeReadAllEvent = function(channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        query: "all"
      }, channel, "read", room);
    };

    SocketEvent.makeSaveEvent = function(obj, channel) {
      var data;

      data = Batman.SocketEvent.fromData(obj);
      data.channel = channel;
      data.request = "save";
      data.room = "all";
      return data;
    };

    SocketEvent.makeRemoveEvent = function(id, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        id: id
      }, channel, "delete", room);
    };

    SocketEvent.fromEvent = function(event) {
      /*
      factory that generate SocketEvent from websocket event
      */
      if (event instanceof Batman.SocketEvent) {
        return event;
      }
      if (event.data == null) {
        throw new Error("No data inside of websocket event");
      }
      return this.fromData(event.data);
    };

    SocketEvent.genId = function() {
      /*
      ##Generates GUI as id for a record
      */
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r, v;

        r = Math.random() * 16 | 0;
        v = (c === "x" ? r : r & 0x3 | 0x8);
        return v.toString(16);
      });
    };

    SocketEvent.fromData = function(data) {
      /*
      factory that generate SocketEvent from the data
      */

      var channel, content, request, room;

      if (data instanceof Batman.SocketEvent) {
        return data;
      }
      if (typeof data === "string") {
        return this.fromString(data);
      }
      if (data.data != null) {
        data = data.data;
      }
      channel = data.channel != null ? data.channel : "default";
      content = data.content != null ? typeof data.content === "string" ? this.toJSON(data.content) : data.content : data;
      request = data.request != null ? data.request : "push";
      room = data.room != null ? data.room : "all";
      return new Batman.SocketEvent(content, channel, request, room);
    };

    SocketEvent.fromString = function(str) {
      /*
      factory that generate SocketEvent from some string
      */

      var data;

      data = this.toJSON(str);
      if (data === void 0 || typeof data === "string") {
        return new Batman.SocketEvent(str, "default", "save");
      } else {
        return this.fromData(data);
      }
    };

    SocketEvent.toJSON = function(str) {
      /*
      tries to convert string to json, returns initial string if failed
      */

      var e, obj;

      if (typeof str !== "string") {
        return str;
      }
      try {
        obj = JSON.parse(str);
      } catch (_error) {
        e = _error;
        return str;
      }
      if (obj === void 0) {
        return str;
      } else {
        return obj;
      }
    };

    return SocketEvent;

  })();

  /*
  # WorkerSocket class #
  */


  Batman.WorkerSocket = (function(_super) {
    __extends(WorkerSocket, _super);

    /*
    #Worker socket#
    */


    function WorkerSocket(worker) {
      this.send = __bind(this.send, this);
      var _this = this;

      if (typeof worker === "string") {
        this.worker = worker = new SharedWorker(worker);
      } else {
        this.worker = worker;
      }
      this.worker.port.onmessage = function(e) {
        return _this.onmessage(e);
      };
      this.worker.port.onerror = function(e) {
        return _this.onerror(e);
      };
      Batman.container.worker = this.worker;
      this.worker.port.start();
      Batman.WorkerSocket.instance = this;
    }

    WorkerSocket.getInstance = function(url) {
      if (url == null) {
        url = "none";
      }
      if (Batman.WorkerSocket.instance != null) {
        return Batman.WorkerSocket.instance;
      } else {
        return new Batman.WorkerSocket(url);
      }
    };

    WorkerSocket.prototype.send = function(obj) {
      return this.worker.port.postMessage(obj);
    };

    WorkerSocket.prototype.onopen = function(i) {};

    WorkerSocket.prototype.onerror = function(error) {};

    WorkerSocket.prototype.onmessage = function(event) {
      var data;

      data = event.data != null ? event.data : event;
      if (data.ready != null) {
        return onopen(data);
      }
    };

    WorkerSocket.prototype.onclose = function() {};

    return WorkerSocket;

  })(Batman.Object);

  /*
  # MockSocket class #
  Mock socket is needed for tests to simulate websocket behaviour
  */


  Batman.MockSocket = (function(_super) {
    __extends(MockSocket, _super);

    /*
    #Mock socket#
    Mock socket is needed for tests to simulate websocket behaviour
    */


    function MockSocket(url) {
      this.url = url;
      this.randomInt = __bind(this.randomInt, this);
      this.onclose = __bind(this.onclose, this);
      this.send = __bind(this.send, this);
      MockSocket.__super__.constructor.apply(this, arguments);
      this.onreceive = Batman.MockSocket.mockCallback(this);
      MockSocket.instance = this;
      this.onopen();
    }

    MockSocket.getInstance = function(url) {
      if (url == null) {
        url = "none";
      }
      if (Batman.MockSocket.instance != null) {
        return Batman.MockSocket.instance;
      } else {
        return new Batman.MockSocket(url);
      }
    };

    MockSocket.prototype.isMock = true;

    MockSocket.prototype.onreceive = function(event) {
      return event;
    };

    MockSocket.prototype.send = function(event) {
      return this.onreceive(event);
    };

    MockSocket.prototype.onopen = function() {
      /*
      Open event
      */
      return console.log("open");
    };

    MockSocket.prototype.onmessage = function(event) {
      /*
      On message
      */

      var data;

      return data = event.data;
    };

    MockSocket.prototype.onclose = function() {
      return console.log("close");
    };

    MockSocket.prototype.randomInt = function(min, max) {
      /*
        random int generating function
      */
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    MockSocket.mockCallback = function(mock) {
      /*
        this callback is needed to store data inside mock sockets and respond to read requests and other queirs
        NAPILNIK
      */
      return function(event) {
        var all, col, content, data, id, message, res;

        data = Batman.SocketEvent.fromString(event);
        switch (data.request) {
          case "save":
            /*
              if we received request to save something we answer to it with result
            */

            data.request = "push";
            if (data.content.id != null) {
              id = data.content.id;
              /*
                if we were give id we just give item with appropriate id
              */

              mock.set(id, data);
              all = mock.getOrSet(data.channel, function() {
                return new Batman.SimpleSet();
              });
              res = all.find(function(item) {
                return item.id === id;
              });
              if (res != null) {
                all.remove(res);
              }
              all.add(data.content);
              return mock.onmessage(data);
            }
            break;
          case "delete":
            if (data.content.id != null) {
              id = data.content.id;
              mock.unset(id);
              all = mock.getOrSet(data.channel, function() {
                return new Batman.SimpleSet();
              });
              res = all.find(function(item) {
                return item.id === id;
              });
              if (res != null) {
                return all.remove(res);
              }
            }
            break;
          case "read":
            if (data.content.id != null) {
              data = mock.get(data.content.id);
              data.request = "answer";
              return mock.onmessage(data);
            } else {
              if ((data.content.query != null) && data.content.query === "all") {
                col = mock.get(data.channel);
                if ((col != null) && col.length > 0) {
                  content = col.toArray();
                  message = new Batman.SocketEvent(content, data.channel, "readAll");
                  return mock.onmessage(message);
                } else {
                  return mock.onmessage(new Batman.SocketEvent("_nil_", data.channel, "readAll"));
                }
              }
            }
        }
      };
    };

    return MockSocket;

  }).call(this, Batman.Object);

  /*
  # MockSocket class #
  Mock socket is needed for tests to simulate websocket behaviour
  */


  Batman.CacheSocket = (function(_super) {
    __extends(CacheSocket, _super);

    CacheSocket.prototype.isMock = true;

    CacheSocket.prototype.isCache = true;

    CacheSocket.prototype.input = [];

    CacheSocket.prototype.onopen = function() {
      /*
      Open event
      */
      return console.log("open");
    };

    function CacheSocket(url) {
      this.url = url;
      this.unapply = __bind(this.unapply, this);
      this.randomInt = __bind(this.randomInt, this);
      this.onclose = __bind(this.onclose, this);
      this.onerror = __bind(this.onerror, this);
      this.send = __bind(this.send, this);
      CacheSocket.__super__.constructor.apply(this, arguments);
      this.input = [];
    }

    CacheSocket.prototype.send = function(data) {
      return this.input.push(data);
    };

    CacheSocket.prototype.onmessage = function(event) {
      /*
      On message
      */

      var data;

      data = event.data;
      return console.log(data);
    };

    CacheSocket.prototype.onerror = function() {
      return console.log("error");
    };

    CacheSocket.prototype.onclose = function() {
      return console.log("close");
    };

    CacheSocket.prototype.randomInt = function(min, max) {
      /*
        random int generating function
      */
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    CacheSocket.prototype.unapply = function(successor) {
      var el, _i, _len, _ref, _results;

      if ((this.input != null) && (successor.send != null)) {
        _ref = this.input;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          el = _ref[_i];
          _results.push(successor.send(el));
        }
        return _results;
      }
    };

    return CacheSocket;

  })(Batman.Object);

  /*
    #Socket class#
    it not only uses either real or mock socket but broadcasts messages to various channels through events
  */


  Batman.Socket = (function(_super) {
    __extends(Socket, _super);

    /*
      websocket wrapper that broadcast info to its channels
      it not only uses either real or mock socket but broadcasts messages to various channels through events
    */


    function Socket(url) {
      this.ask = __bind(this.ask, this);
      this.send = __bind(this.send, this);
      this.getVideoChannel = __bind(this.getVideoChannel, this);
      this.getSpecialChannel = __bind(this.getSpecialChannel, this);
      this.getChannel = __bind(this.getChannel, this);
      this.withUrl = __bind(this.withUrl, this);
      this.getWebSocket = __bind(this.getWebSocket, this);
      this.addSocketHandlers = __bind(this.addSocketHandlers, this);
      this.setWebsocket = __bind(this.setWebsocket, this);
      this.createWebSocket = __bind(this.createWebSocket, this);
      this.isMock = __bind(this.isMock, this);
      /*
      creates a socket object
      */
      this.router = new Batman.SimpleRouter();
      this.websocket = this.getWebSocket(url);
      Batman.Socket.instance = this;
    }

    Socket.prototype.url = "none";

    Socket.prototype.isMock = function() {
      return (this.websocket == null) || (this.websocket.isMock != null);
    };

    Socket.prototype.createWebSocket = function(url) {
      /*
        creates websocket or mocksocket
      */

      var websocket;

      if (url === "none") {
        websocket = new Batman.CacheSocket(url);
      } else {
        websocket = new WebSocket(url);
      }
      this.url = url;
      return this.setWebsocket(websocket);
    };

    Socket.prototype.setWebsocket = function(websocket) {
      var defOpen, old,
        _this = this;

      defOpen = function(event) {
        _this.websocket = websocket;
        return _this.addSocketHandlers(_this.websocket);
      };
      if (this.websocket != null) {
        if (websocket === this.websocket) {
          return this.websocket;
        }
        if (this.websocket.isCache != null) {
          old = this.websocket;
          websocket.onopen = function(event) {
            defOpen(event);
            return old.unapply(websocket);
          };
        } else {
          websocket.onopen = defOpen;
        }
      } else {
        websocket.onopen = defOpen;
      }
      if (websocket.isMock != null) {
        return websocket.onopen();
      }
    };

    Socket.prototype.addSocketHandlers = function(websocket) {
      var _this = this;

      websocket.onmessage = function(event) {
        return _this.broadcast(event);
      };
      websocket.onerror = function(err) {
        return alert("some ERROR occured");
      };
      websocket.onclose = function() {
        return alert("socket is CLOSED");
      };
      return websocket;
    };

    Socket.prototype.broadcast = function(info) {
      return this.router.broadcast(info, this);
    };

    Socket.prototype.getWebSocket = function(url) {
      /*
        TODO: rewrite, all this searches, the global scope only confuses
      */
      if (Batman.container.websocket != null) {
        if ((Batman.container.websocket.isMock && url === 'none') || url === this.url) {
          return Batman.container.websocket;
        }
      }
      return this.createWebSocket(url);
    };

    Socket.prototype.withUrl = function(url) {
      /*
        returns self but changes the websocket if needed
      */
      if (url !== this.url) {
        this.websocket = this.getWebSocket(url);
      }
      return this;
    };

    Socket.getInstance = function(url) {
      if (url == null) {
        url = "none";
      }
      /*
        works as singletone
        TODO: rewrite
      */

      if (Batman.Socket.instance != null) {
        return Batman.Socket.instance;
      } else {
        return new Batman.Socket(url);
      }
      /*
      if Batman.container.socket?
        return Batman.container.socket.withUrl(url)
      else
        return new Batman.Socket(url)
      */

    };

    Socket.prototype.getChannel = function(name) {
      /*
        gets or creates channel
      */

      var _this = this;

      return this.getOrSet(name, function() {
        return new Batman.Channel(name).attach(_this);
      });
    };

    Socket.prototype.getSpecialChannel = function(name, factory) {
      /*
        gets or creates channel with factory that is provided
      */

      var _this = this;

      return this.getOrSet(name, function() {
        return factory().attach(_this);
      });
    };

    Socket.prototype.getVideoChannel = function(name, room) {
      /*
        gets or creates video channel
      */

      var _this = this;

      return this.getOrSet(name + "2" + room, function() {
        return new Batman.VideoChannel(name, room).attach(_this);
      });
    };

    Socket.prototype.send = function(obj) {
      return this.router.send(obj, this.websocket);
    };

    Socket.prototype.ask = function(question) {
      /*
        executes if there is a request to the router (but without info to be send to server)
      */
      return this.router.respond(question, this);
    };

    return Socket;

  }).call(this, Batman.Object);

  /*
  # Channel class #
  Every sockets info to channels.
  Channels are needed to communicate directly with the model
  */


  Batman.Channel = (function(_super) {
    __extends(Channel, _super);

    /*
    #Channel class
    Every sockets info to channels.
    Channels are needed to communicate directly with the model
    */


    function Channel(name) {
      this.attach = __bind(this.attach, this);
      this.ask = __bind(this.ask, this);
      this.onmessage = __bind(this.onmessage, this);
      this.onNextMessage = __bind(this.onNextMessage, this);
      this.receive = __bind(this.receive, this);
      this.send = __bind(this.send, this);
      this.askWebcam = __bind(this.askWebcam, this);
      this.stream2src = __bind(this.stream2src, this);
      this.query = __bind(this.query, this);
      this.lookup = __bind(this.lookup, this);
      this.remove = __bind(this.remove, this);
      this.readAll = __bind(this.readAll, this);
      this.read = __bind(this.read, this);
      this.save = __bind(this.save, this);
      this.save = __bind(this.save, this);
      var _this = this;

      this.name = name;
      this.on("onmessage", function(event) {
        return _this.onmessage(event);
      });
    }

    Channel.prototype.save = function(obj, id) {
      obj.id = id;
      return this.save(obj);
    };

    Channel.prototype.save = function(obj) {
      return this.fire("send", Batman.SocketEvent.makeSaveEvent(obj, this.name));
    };

    Channel.prototype.read = function(id) {
      return this.fire("send", Batman.SocketEvent.makeReadEvent(id, this.name));
    };

    Channel.prototype.readAll = function() {
      return this.fire("send", Batman.SocketEvent.makeReadAllEvent(this.name));
    };

    Channel.prototype.remove = function(id) {
      return this.fire("send", Batman.SocketEvent.makeRemoveEvent(id, this.name));
    };

    Channel.prototype.lookup = function(field, query) {
      return this.fire("send", Batman.SocketEvent.makeLookupEvent(field, query, this.name));
    };

    Channel.prototype.query = function(query) {
      return this.fire("send", Batman.SocketEvent.makeQueryEvent(query, this.name));
    };

    Channel.prototype.stream2src = function(stream) {
      /*
        gets URL from the stream
      */
      if (window.URL != null) {
        return window.URL.createObjectURL(stream);
      } else {
        if (window.webkitURL != null) {
          return window.webkitURL.createObjectURL(stream);
        } else {
          if (window.mozURL != null) {
            return window.mozURL.createObjectURL(stream);
          } else {
            return stream;
          }
        }
      }
    };

    Channel.prototype.askWebcam = function() {
      return this.ask("webcam");
    };

    Channel.prototype.send = function(obj) {
      var data;

      data = Batman.SocketEvent.fromData(obj);
      data.channel = this.name;
      return this.fire("send", data);
    };

    Channel.prototype.receive = function(event) {
      this.fire("onmessage", event);
      return this.fire(event.request, event);
    };

    Channel.prototype.onNextMessage = function(fun) {
      var _this = this;

      return this.once("onmessage", function(event) {
        return fun(event);
      });
    };

    Channel.prototype.onmessage = function(event) {
      /*
        call back the receives info from socket send to this channel
      */

    };

    Channel.prototype.ask = function(question) {
      /*
        asks router for some additional info
      */
      return this.fire("ask", question);
    };

    Channel.prototype.attach = function(obj) {
      /*
        Attaches the channel to the socket wrapper and subscribes to its events
      */

      var cl, receive, send;

      receive = this.receive;
      obj.on(this.name, receive);
      obj.on("all", receive);
      send = obj.send;
      this.on("send", send);
      this.on("ask", obj.ask);
      cl = this.constructor.name;
      obj.fire(cl, this.name);
      return this;
    };

    return Channel;

  })(Batman.Object);

  /*
    video channel class, temporal version
    will be refactored in the future
  */


  Batman.VideoChannel = (function(_super) {
    __extends(VideoChannel, _super);

    VideoChannel.prototype.peer = null;

    /*
      mystream is a temporal global variable to save a stream from a webcome
    */


    function VideoChannel(name, room, myStream) {
      var _this = this;

      this.room = room;
      this.myStream = myStream != null ? myStream : null;
      this.attach = __bind(this.attach, this);
      this.attach = __bind(this.attach, this);
      this.subscribeRemote = __bind(this.subscribeRemote, this);
      this.subscribeLocal = __bind(this.subscribeLocal, this);
      this.onGetICE = __bind(this.onGetICE, this);
      this.onCreateICE = __bind(this.onCreateICE, this);
      this.onGetRemoteStream = __bind(this.onGetRemoteStream, this);
      this.onGetAnswer = __bind(this.onGetAnswer, this);
      this.onCreateAnswer = __bind(this.onCreateAnswer, this);
      this.onGetOffer = __bind(this.onGetOffer, this);
      this.onCreateOffer = __bind(this.onCreateOffer, this);
      this.call = __bind(this.call, this);
      this.onWebCamSuccess = __bind(this.onWebCamSuccess, this);
      this.makePeer = __bind(this.makePeer, this);
      this.startPeer = __bind(this.startPeer, this);
      this.askWebcam = __bind(this.askWebcam, this);
      VideoChannel.__super__.constructor.call(this, name);
      this.set("src", "");
      this.startPeer();
      this.on("ICE", function(event) {
        return _this.onGetICE(event.content);
      });
      this.on("offer", function(event) {
        return _this.onGetOffer(event.content);
      });
      this.on("answer", function(event) {
        return _this.onGetAnswer(event.content);
      });
    }

    VideoChannel.prototype.askWebcam = function() {
      return this.ask("webcam");
    };

    VideoChannel.prototype.startPeer = function(servers) {
      if (servers == null) {
        servers = null;
      }
      /*
      starts p2p connection
      */

      this.peer = this.makePeer();
      this.peer.onicecandidate = this.onCreateICE;
      return this.peer.onaddstream = this.onGetRemoteStream;
    };

    VideoChannel.prototype.makePeer = function(servers) {
      if (servers == null) {
        servers = null;
      }
      if (window.RTCPeerConnection != null) {
        return new RTCPeerConnection(servers);
      } else {
        if (window.mozRTCPeerConnection != null) {
          return new mozRTCPeerConnection(servers);
        } else {
          return new webkitRTCPeerConnection(servers);
        }
      }
    };

    VideoChannel.prototype.onWebCamSuccess = function(stream) {
      /*
        when webcam stream received
      */

      var _this = this;

      this.myStream = stream;
      this.peer.onaddstream = function(st) {};
      this.peer.addStream(stream);
      this.peer.onaddstream = this.onGetRemoteStream;
      return this.fire("localStream", stream);
    };

    VideoChannel.prototype.call = function() {
      /*
        Makes a call
      */
      console.log("VideoChannel CALL from " + this.name + " 2 " + this.room);
      if (this.myStream != null) {
        return this.peer.createOffer(this.onCreateOffer);
      } else {
        this.askWebcam();
        return this.on("localStream", this.call);
      }
    };

    VideoChannel.prototype.onCreateOffer = function(desc) {
      /*
        fires when you propose and offer
      */

      var offer;

      this.peer.setLocalDescription(desc);
      offer = Batman.SocketEvent.makeEvent(desc, this.name, "offer", this.room);
      return this.fire("send", offer);
    };

    VideoChannel.prototype.onGetOffer = function(event) {
      /*
        fires when you received another's offer
      */

      var desc;

      desc = new RTCSessionDescription(event);
      this.peer.setRemoteDescription(desc);
      this.peer.createAnswer(this.onCreateAnswer);
      return console.log("offer received");
    };

    VideoChannel.prototype.onCreateAnswer = function(desc) {
      /*
        fires when you created an answer
      */

      var answer;

      this.peer.setLocalDescription(desc);
      answer = Batman.SocketEvent.makeEvent(desc, this.name, "answer", this.room);
      return this.fire("send", answer);
    };

    VideoChannel.prototype.onGetAnswer = function(event) {
      /*
        fires when you received an answer
      */

      var desc;

      desc = new RTCSessionDescription(event);
      this.peer.setRemoteDescription(desc);
      return console.log("answer received");
    };

    VideoChannel.prototype.onGetRemoteStream = function(e) {
      /*
        fires when you got stream
      */

      var stream;

      console.log("got remote stream");
      if (e.stream != null) {
        stream = e.stream;
        return this.fire("remoteStream", stream);
      } else {
        return alert("bug in onGetRemoteStream");
      }
    };

    VideoChannel.prototype.onCreateICE = function(event) {
      /*
        fires when you make an ICE candidates
      */

      var cand, evt;

      if (event.candidate != null) {
        cand = event.candidate;
        evt = Batman.SocketEvent.makeEvent(cand, this.name, "ICE", this.room);
        return this.fire("send", evt);
      }
      /*
      else
        alert "onICE do not work well"
        alert JSON.stringify(event)
      */

    };

    VideoChannel.prototype.onGetICE = function(event) {
      /*
        fires when you received and ICE
      */
      return this.peer.addIceCandidate(new RTCIceCandidate(event));
    };

    /*
    onmessage: (event)=>
      switch event.request
        when "ICE" then @onGetICE(event.content)
        when "offer" then  @onGetOffer(event.content)
        when "answer" then @onGetAnswer(event.content)
    */


    VideoChannel.prototype.onError = function(e) {
      return alert("There has been a problem retrieving the streams - did you allow access?");
    };

    VideoChannel.prototype.subscribeLocal = function(vid) {
      var _this = this;

      return this.on("localStream", function(stream) {
        var src;

        src = _this.stream2src(stream);
        _this.set("src", src);
        return vid.src = src;
      });
    };

    VideoChannel.prototype.subscribeRemote = function(vid) {
      var _this = this;

      return this.on("remoteStream", function(stream) {
        var src;

        src = _this.stream2src(stream);
        _this.set("src", src);
        return vid.src = src;
      });
    };

    VideoChannel.prototype.attach = function(obj) {
      /*
        Attaches the channel to the socket wrapper and subscribes to its events
      */

      var cl, receive, send;

      receive = this.receive;
      if ((this.room != null) && this.room !== "all") {
        obj.on(this.name + "2" + this.room, receive);
      } else {
        obj.on(this.name, receive);
      }
      obj.on("all", receive);
      send = obj.send;
      this.on("send", send);
      this.on("ask", obj.ask);
      cl = this.constructor.name;
      obj.fire(cl, this.name);
      return this;
    };

    VideoChannel.prototype.attach = function(obj) {
      var onStream;

      onStream = this.onWebCamSuccess;
      obj.on("localStream", onStream);
      VideoChannel.__super__.attach.call(this, obj);
      if (this.myStream != null) {
        this.peer.addStream(this.myStream);
        this.peer.onaddstream = this.onGetRemoteStream;
      } else {
        this.askWebcam();
      }
      return this;
    };

    return VideoChannel;

  })(Batman.Channel);

  Batman.VideoSlotChannel = (function(_super) {
    __extends(VideoSlotChannel, _super);

    VideoSlotChannel.prototype.channels = null;

    VideoSlotChannel.prototype.OPEN_PEERS = "openpeers";

    VideoSlotChannel.prototype.PEERS_OPENED = "peersopened";

    VideoSlotChannel.prototype.CALL_PEERS = "callpeers";

    VideoSlotChannel.prototype.PEERS_CALLED = "peerscalled";

    VideoSlotChannel.prototype.CLOSE_PEERS = "closepeers";

    VideoSlotChannel.prototype.PEERS_CLOSED = "peersclosed";

    /*
      mystream is a temporal global variable to save a stream from a webcome
    */


    function VideoSlotChannel(name, room) {
      var _this = this;

      this.room = room;
      this.open = __bind(this.open, this);
      this.call = __bind(this.call, this);
      this.peersCalled = __bind(this.peersCalled, this);
      this.peersOpened = __bind(this.peersOpened, this);
      VideoSlotChannel.__super__.constructor.call(this, name);
      this.channels = new Batman.SimpleHash();
      this.on(this.OPEN_PEERS, function(event) {
        return _this.peersOpened(event);
      });
      this.on(this.CALL_PEERS, function(event) {
        return _this.peersCalled(event);
      });
    }

    VideoSlotChannel.prototype.peersOpened = function(event) {
      /*
        fires when we received peers to be created
      */

      var ch, cont, f, h, socket, t, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;

      console.log("PEERS OPENED: " + JSON.stringify(event));
      if (!event.content) {
        console.log("no content");
      }
      cont = event.content;
      if (!((cont.from != null) || cont.to)) {
        console.log("no from or to");
      }
      socket = Batman.Socket.getInstance();
      _ref = cont.from;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        h = this.channels.getOrSet(f, function() {
          return new Batman.SimpleHash();
        });
        _ref1 = cont.to;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          t = _ref1[_j];
          console.log("open video channel from " + f + " to " + t);
          ch = h.getOrSet(t, function() {
            return socket.getVideoChannel(f, t);
          });
          ch.on("localStream", function(stream) {
            return _this.fire("local", _this.stream2src(stream));
          });
          ch.on("remoteStream", function(stream) {
            var src;

            src = _this.stream2src(stream);
            console.log("" + _this.name + ": remoteSRC = " + src);
            return _this.fire("remote", src);
          });
        }
      }
      event.content.name = this.PEERS_OPENED;
      event.request = this.PEERS_OPENED;
      event.room = this.room;
      this.send(event);
      return this.fire(this.PEERS_OPENED);
    };

    VideoSlotChannel.prototype.peersCalled = function(event) {
      /*
        fires when we received peers to be created
      */

      var ch, cont, f, h, socket, t, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;

      console.log("PEERS CALLED: " + JSON.stringify(event));
      if (!event.content) {
        console.log("no content");
      }
      cont = event.content;
      if (!((cont.from != null) || cont.to)) {
        console.log("no from or to");
      }
      socket = Batman.Socket.getInstance();
      _ref = cont.from;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        h = this.channels.getOrSet(f, function() {
          return new Batman.SimpleHash();
        });
        _ref1 = cont.to;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          t = _ref1[_j];
          console.log("call video channel from " + f + " to " + t);
          ch = h.getOrSet(t, function() {
            return socket.getVideoChannel(f, t);
          });
          ch.call();
        }
      }
      event.content.name = this.PEERS_CALLED;
      event.request = this.PEERS_CALLED;
      event.room = this.room;
      this.send(event);
      return this.fire(this.PEERS_CALLED);
    };

    VideoSlotChannel.prototype.call = function() {
      var evt, req;

      req = "broadcast";
      evt = new Batman.SocketEvent(req, this.name, req, this.room);
      return this.fire("send", evt);
    };

    VideoSlotChannel.prototype.open = function() {
      var content, evt, req;

      req = "video";
      content = {
        name: req
      };
      evt = new Batman.SocketEvent(content, this.name, req, this.room);
      return this.fire("send", evt);
    };

    VideoSlotChannel.prototype.onError = function(e) {
      return alert("There has been a problem with slot channel?");
    };

    return VideoSlotChannel;

  })(Batman.Channel);

  /*
    Routerclass
  */


  Batman.SimpleRouter = (function(_super) {
    __extends(SimpleRouter, _super);

    function SimpleRouter() {
      _ref = SimpleRouter.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
      Simple router does only simple broadcasting relying on channel info from the socket
    */


    SimpleRouter.prototype.broadcast = function(info, socket) {
      /*
        transforms info into SocketEvents and routes them further, to the channels
        some routers split info into several parts and send to difference channels
      */

      var event;

      event = Batman.SocketEvent.fromEvent(info);
      /* broadcasts the message further
      */

      if (!(event instanceof Batman.SocketEvent)) {
        throw Error('should be socket event');
      }
      /* broadcast event to appropriate channels
      */

      socket.fire(event.channel, event);
      if ((event.room != null) && event.room !== "all") {
        return socket.fire(event.channel + "2" + event.room, event);
      }
    };

    SimpleRouter.prototype.send = function(obj, websocket) {
      /*
        sends event to the websocket
      */

      var str;

      if (typeof obj === 'string') {
        return websocket.send(obj);
      } else {
        str = JSON.stringify(Batman.SocketEvent.fromData(obj));
        return websocket.send(str);
      }
    };

    SimpleRouter.prototype.myStream = null;

    SimpleRouter.prototype.webCamPending = false;

    SimpleRouter.prototype.respond = function(question, socket) {
      /*
        respond to questions from channels
      */

      var onerror, onsuccess,
        _this = this;

      switch (question) {
        case "webcam":
          if (this.myStream != null) {
            return socket.fire("localStream", this.myStream);
          } else {
            if (this.webCamPending === false) {
              navigator.getUserMedia || (navigator.getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia);
              if (navigator.getUserMedia) {
                onsuccess = function(stream) {
                  socket.fire("localStream", stream);
                  return _this.webCamPending = false;
                };
                onerror = this.onError;
                this.webCamPending = true;
                navigator.getUserMedia({
                  video: true,
                  audio: true
                }, onsuccess, onerror);
              } else {
                alert("getUserMedia is not supported in this browser.");
              }
            }
            return this.webCamPending = true;
          }
      }
    };

    return SimpleRouter;

  })(Batman.Object);

  /*
    Chat router class
  */


  Batman.ChatRouter = (function(_super) {
    __extends(ChatRouter, _super);

    function ChatRouter() {
      _ref1 = ChatRouter.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    ChatRouter.prototype.broadcast = function(info, socket) {
      /*
        routes events to the chat
      */

      var data;

      if (info.data == null) {
        return ChatRouter.__super__.broadcast.call(this, info, socket);
      }
      if (info.data.content != null) {
        return ChatRouter.__super__.broadcast.call(this, info, socket);
      }
      data = Batman.SocketEvent.toJSON(info.data);
      if (data.kind != null) {
        switch (data.kind) {
          case "join":
            this.addUser(data, socket);
            return this.message(data, socket);
          case "quit":
            this.removeUser(data, socket);
            return this.message(data, socket);
          case "talk":
            return this.message(data, socket);
          case "message":
            return this.message(data, socket);
        }
      }
    };

    ChatRouter.prototype.addUser = function(data, socket) {
      var content, event;

      content = {
        id: data.user,
        name: data.user
      };
      event = new Batman.SocketEvent.makePushEvent(content, "users");
      return socket.fire("users", event);
    };

    ChatRouter.prototype.removeUser = function(data, socket) {
      return socket.fire("users", Batman.SocketEvent.makeRemoveEvent(data.user, "users"));
    };

    ChatRouter.prototype.message = function(data, socket) {
      var content, event, text;

      text = data.message != null ? data.message : data.text;
      content = {
        "user": data.user,
        "text": text
      };
      event = Batman.SocketEvent.makePushEvent(content, "messages");
      return socket.fire("messages", event);
    };

    ChatRouter.prototype.task = function(data, socket) {
      var content, event;

      content = {
        "user": data.user,
        "title": data.title
      };
      event = Batman.SocketEvent.makePushEvent(content, "tasks");
      return socket.fire("tasks", event);
    };

    ChatRouter.prototype.send = function(obj, websocket) {
      /*
        sends event to the websocket
      */

      var event, str;

      if (typeof obj === 'string') {
        return websocket.send(obj);
      } else {
        event = Batman.SocketEvent.fromData(obj);
        if (event.channel === "messages") {
          if (event.content != null) {
            if (event.content.text != null) {
              event.text = event.content.text;
            } else {
              if (event.content.data != null) {
                event.text = event.content.data;
              } else {
                event.text = event.content;
              }
            }
          }
        }
        str = JSON.stringify(Batman.SocketEvent.fromData(obj));
        return websocket.send(str);
      }
    };

    return ChatRouter;

  })(Batman.SimpleRouter);

  /*
  #SocketStorage#
  
  This is a Socket storage adaptor needed to connect Batman's models to websocket
  It has not been finished yet.
  */


  Batman.SocketStorage = (function(_super) {
    __extends(SocketStorage, _super);

    /*
    #SocketStorage#
    
    This is a Socket storage adaptor needed to connect Batman's models to websocket
    It has not been finished yet.
    */


    function SocketStorage(model) {
      /*
        Initialize storage adaptor as well as socket
      */
      SocketStorage.__super__.constructor.call(this, model);
      this.socket = new Batman.Socket.getInstance();
    }

    SocketStorage.prototype._dataMatches = function(conditions, data) {
      var k, match, v;

      match = true;
      for (k in conditions) {
        v = conditions[k];
        if (data[k] !== v) {
          match = false;
          break;
        }
      }
      return match;
    };

    SocketStorage.prototype.subscribe = function(model) {
      /*
        Subscribe model to different events
        subscribe function is called after readall
      */

      var channel, key,
        _this = this;

      channel = this.socket.getChannel(model.storageKey);
      if (model.primaryKey != null) {
        key = model.primaryKey;
      } else {
        key = "id";
      }
      channel.on("push", function(event) {
        var all, record, res;

        all = model.get("loaded");
        res = all.find(function(item) {
          return item.get(key) === event.content[key];
        });
        all.remove(res);
        record = _this.getRecordFromData(event.content, model);
        return all.add(record);
      });
      channel.on("delete", function(event) {
        var all, res;

        all = model.get("loaded");
        res = all.find(function(item) {
          return item.get(key) === event.content[key];
        });
        return all.remove(res);
      });
      return channel;
    };

    SocketStorage.prototype.readAll = function(env, next) {
      /*
      overrided readAll to add subscription
      TODO: what to do with subscriptions if readALL is called several times?
      */

      var channel, options;

      channel = this.subscribe(env.subject);
      options = env.options.data;
      channel.onNextMessage(function(event) {
        var error, item, records, _i, _len, _ref2;

        try {
          records = [];
          if ((event.content != null) && (event.content.length != null)) {
            _ref2 = event.content;
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              item = _ref2[_i];
              if (this._dataMatches(options, item)) {
                records.push(item);
              }
            }
          }
          env.recordsAttributes = records;
        } catch (_error) {
          error = _error;
          env.error = error;
        }
        return next();
      });
      return channel.readAll();
    };

    SocketStorage.prototype.create = function(_arg, next) {
      var channel, id, key, recordAttributes;

      key = _arg.key, id = _arg.id, recordAttributes = _arg.recordAttributes;
      channel = this.socket.getChannel(key);
      channel.save(recordAttributes, id);
      return next();
    };

    SocketStorage.prototype.read = function(_arg, next) {
      var channel, id, key, recordAttributes,
        _this = this;

      key = _arg.key, id = _arg.id, recordAttributes = _arg.recordAttributes;
      channel = this.socket.getChannel(key);
      channel.onNextMessage(function() {
        if (!env.recordAttributes) {
          env.error = new _this.constructor.NotFoundError();
          return next();
        }
      });
      return channel.read(id);
    };

    SocketStorage.prototype.update = function(_arg, next) {
      var channel, id, key, recordAttributes;

      key = _arg.key, id = _arg.id, recordAttributes = _arg.recordAttributes;
      channel = this.socket.getChannel(key);
      channel.save(recordAttributes, id);
      return next();
    };

    SocketStorage.prototype.destroy = function(_arg, next) {
      var channel, id, key;

      key = _arg.key, id = _arg.id;
      channel = this.socket.getChannel(key);
      channel.remove(id);
      return next();
    };

    SocketStorage.prototype.before('read', 'create', 'update', 'destroy', SocketStorage.skipIfError(function(env, next) {
      var key,
        _this = this;

      if (env.action === 'create') {
        env.id = env.subject.get('id') || env.subject._withoutDirtyTracking(function() {
          return env.subject.set('id', Batman.SocketEvent.genId());
        });
      } else {
        env.id = env.subject.get('id');
      }
      if (env.id == null) {
        env.error = new this.constructor.StorageError("Couldn't get/set record primary key on " + env.action + "!");
      }
      key = this.storageKey(env.subject);
      env.key = key;
      return next();
    }));

    SocketStorage.prototype.before('create', 'update', SocketStorage.skipIfError(function(env, next) {
      env.recordAttributes = JSON.stringify(env.subject);
      return next();
    }));

    SocketStorage.prototype.after('read', SocketStorage.skipIfError(function(env, next) {
      var error;

      if (typeof env.recordAttributes === 'string') {
        try {
          env.recordAttributes = this._jsonToAttributes(env.recordAttributes);
        } catch (_error) {
          error = _error;
          env.error = error;
          return next();
        }
      }
      env.subject._withoutDirtyTracking(function() {
        return this.fromJSON(env.recordAttributes);
      });
      return next();
    }));

    SocketStorage.prototype.after('read', 'create', 'update', 'destroy', SocketStorage.skipIfError(function(env, next) {
      env.result = env.subject;
      return next();
    }));

    SocketStorage.prototype.after('readAll', SocketStorage.skipIfError(function(env, next) {
      var recordAttributes;

      env.result = env.records = (function() {
        var _i, _len, _ref2, _results;

        _ref2 = env.recordsAttributes;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          recordAttributes = _ref2[_i];
          _results.push(this.getRecordFromData(recordAttributes, env.subject));
        }
        return _results;
      }).call(this);
      return next();
    }));

    return SocketStorage;

  })(Batman.StorageAdapter);

}).call(this);

/*
//@ sourceMappingURL=collab.map
*/
