// Generated by CoffeeScript 1.6.2
(function() {
  var _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Batman.BetterView = (function(_super) {
    __extends(BetterView, _super);

    function BetterView() {
      _ref = BetterView.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
      this view is an alternative to Batman's default's one prodiving an ability to
    */


    BetterView.prototype.node = false;

    BetterView.prototype.options = null;

    BetterView.register = function(key, param) {
      /*
        as default option of Batman seems to be buggy I had to write my own function for that
        it stores key to be used for view creation
        on rendered values of all from data-view-{key} will be saved inside the view
      */

      var _base, _ref1;

      if ((_ref1 = (_base = this.prototype).options) == null) {
        _base.options = new Batman.SimpleHash;
      }
      return this.prototype.options.set(key, param);
    };

    BetterView.prototype.render = function() {
      var fun,
        _this = this;

      BetterView.__super__.render.apply(this, arguments);
      this.node = this.get("node");
      fun = function(key, param) {
        var attr, path;

        path = ("data-view-" + key).toLowerCase();
        if (_this.node.hasAttribute(path)) {
          attr = _this.node.getAttribute(path);
          return _this.set(key, attr);
        } else {
          if (param === "mandatory") {
            return Batman.developer.error("there is no mandatory option " + key + " for the view");
          }
        }
      };
      if (this.options != null) {
        return this.options.forEach(fun);
      }
    };

    BetterView.prototype.keyCode = {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      NUMPAD_ADD: 107,
      NUMPAD_DECIMAL: 110,
      NUMPAD_DIVIDE: 111,
      NUMPAD_ENTER: 108,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_SUBTRACT: 109,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    };

    return BetterView;

  })(Batman.View);

  Batman.ChannelView = (function(_super) {
    __extends(ChannelView, _super);

    function ChannelView() {
      _ref1 = ChannelView.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    /*
    View that is connected to some socket channel
    */


    ChannelView.prototype.channelName = null;

    ChannelView.prototype.channel = null;

    ChannelView.register("key", "mandatory");

    ChannelView.prototype.connect = function() {
      /*
        works with channel
      */

      var _ref2;

      if ((_ref2 = this.channelName) == null) {
        this.channelName = this.get("key");
      }
      return this.channel = Batman.Socket.getInstance().getChannel(this.channelName);
    };

    ChannelView.prototype.render = function() {
      ChannelView.__super__.render.apply(this, arguments);
      return this.connect();
    };

    return ChannelView;

  })(Batman.BetterView);

  Denigma.UserView = (function(_super) {
    __extends(UserView, _super);

    function UserView() {
      UserView.__super__.constructor.apply(this, arguments);
    }

    return UserView;

  })(Batman.View);

  Denigma.MessageView = (function(_super) {
    __extends(MessageView, _super);

    /*
      View for messages of this chat
    */


    function MessageView() {
      MessageView.__super__.constructor.apply(this, arguments);
    }

    MessageView.prototype.render = function() {
      var node;

      MessageView.__super__.render.apply(this, arguments);
      node = $(this.get("node"));
      return node.hide().fadeIn("slow");
    };

    return MessageView;

  })(Batman.View);

  Denigma.TaskView = (function(_super) {
    __extends(TaskView, _super);

    function TaskView() {
      TaskView.__super__.constructor.apply(this, arguments);
    }

    TaskView.prototype.render = function() {
      return TaskView.__super__.render.apply(this, arguments);
    };

    return TaskView;

  })(Batman.View);

  /*
    In many cases we need to search with search suggessions, t
    he intention of this class if to provide such functionality
  */


  Denigma.SearchBoard = (function(_super) {
    __extends(SearchBoard, _super);

    SearchBoard.edit = null;

    function SearchBoard() {
      this.bind = __bind(this.bind, this);
      this.keyDownHandler = __bind(this.keyDownHandler, this);
      this.multiSelect = __bind(this.multiSelect, this);
      this.select = __bind(this.select, this);
      this.focus = __bind(this.focus, this);
      this.look = __bind(this.look, this);
      this.extractLast = __bind(this.extractLast, this);
      this.split = __bind(this.split, this);
      this.lookup = __bind(this.lookup, this);
      this.searchHandler = __bind(this.searchHandler, this);
      this.lookupHandler = __bind(this.lookupHandler, this);      SearchBoard.__super__.constructor.apply(this, arguments);
      this.set("titles", new Batman.Set());
      this.set("results", new Batman.Set());
    }

    SearchBoard.register("result");

    SearchBoard.register("field");

    SearchBoard.register("input");

    SearchBoard.prototype.lookupHandler = function(event) {
      /*
        fires when lookup info received
      */

      var t, tlt, _i, _len, _ref2;

      tlt = this.get("titles");
      tlt.clear();
      _ref2 = event.content.list;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        t = _ref2[_i];
        tlt.add(t);
      }
      return this.set("titles", tlt);
    };

    SearchBoard.prototype.searchHandler = function(event) {
      /*
        fires when search resultsreceived
      */

      var r, res, _i, _len, _ref2, _results;

      this.get("titles").clear();
      res = this.get("results");
      res.clear();
      _ref2 = event.content.list;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        r = _ref2[_i];
        _results.push(res.add(r));
      }
      return _results;
    };

    SearchBoard.prototype.render = function() {
      var inp, node;

      SearchBoard.__super__.render.apply(this, arguments);
      node = $(this.get("node"));
      inp = "#" + this.get("input");
      this.edit = $(inp);
      return this.bind(this.edit);
    };

    SearchBoard.prototype.connect = function() {
      /*
        works with channel
      */

      var searchme;

      SearchBoard.__super__.connect.apply(this, arguments);
      searchme = this.searchHandler;
      return this.channel.on("search", searchme);
    };

    SearchBoard.accessor("active", function() {
      return this.get("query").length > 0;
    });

    SearchBoard.prototype.lookup = function(newVal, oldVal) {
      var field;

      if (this.channel != null) {
        field = this.get("field");
        if ((field != null)) {
          return this.channel.lookup(field, newVal);
        } else {
          console.log("no field " + field);
          return this.channel.query(newVal);
        }
      } else {
        return alert("no suggesssion channel!");
      }
    };

    SearchBoard.prototype.split = function(val) {
      return val.split(" ");
    };

    SearchBoard.prototype.extractLast = function(term) {
      if (term != null) {
        return this.split(term).pop();
      }
    };

    SearchBoard.prototype.look = function(request, response) {
      /*
        sends request to the channel
      */

      var field, lookme, onceHandler, term,
        _this = this;

      term = this.extractLast(request.term);
      field = this.get("field");
      onceHandler = function(event) {
        var titles;

        lookme(event);
        titles = _this.get("titles");
        return response(titles.toArray());
      };
      this.channel.lookup(field, term);
      lookme = this.lookupHandler;
      return this.channel.once("lookup", onceHandler);
    };

    SearchBoard.prototype.focus = function() {
      return false;
    };

    SearchBoard.prototype.select = function(event, ui) {
      /*
        fires when you selected the term
      */

      var name, newVal, s1, s2, value;

      newVal = ui.item.value;
      s1 = newVal.indexOf("(");
      s2 = newVal.indexOf(")");
      if (s1 > 1 && s2 > s1) {
        name = newVal.substring(0, s1 - 1);
        value = newVal.substring(s1 + 1, newVal.length - 1);
      } else {
        name = newVal;
        value = newVal;
      }
      this.edit.val(name);
      Denigma.fire("fisheye", value, "genesgraph");
      return true;
    };

    SearchBoard.prototype.multiSelect = function(event, ui) {
      var newVal, terms, value;

      value = this.edit.val();
      terms = this.split(value);
      newVal = ui.item.value;
      terms.pop();
      terms.push(newVal);
      terms.push(" ");
      this.edit.val(terms.join(" "));
      return false;
    };

    SearchBoard.prototype.keyDownHandler = function(event) {
      if (event.keyCode === $.ui.keyCode.TAB && $(this).data("ui-autocomplete").menu.active) {
        return event.preventDefault();
      }
    };

    SearchBoard.prototype.bind = function(input) {
      var focus, minLength, select, source;

      minLength = 2;
      source = this.look;
      select = this.select;
      focus = this.focus;
      return input.bind("keydown", this.keyDownHandler).autocomplete({
        minLength: minLength,
        delay: 300,
        source: source,
        select: select,
        focus: focus
      });
    };

    return SearchBoard;

  })(Batman.ChannelView);

}).call(this);

/*
//@ sourceMappingURL=views.map
*/
