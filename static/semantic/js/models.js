// Generated by CoffeeScript 1.6.2
/*
#User class#
model for users of the chat, now is only used for test purposes
Class for chat users
*/


(function() {
  var _ref, _ref1, _ref2, _ref3,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Denigma.User = (function(_super) {
    __extends(User, _super);

    /*
    Class for chat users
    */


    function User() {
      _ref = User.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    User.encode('username', 'status', 'password');

    User.validate('name', {
      presence: true
    });

    User.persist(Batman.SocketStorage);

    /*
      messages are stored in socket storage
    */


    User.primaryKey = 'username';

    User.storageKey = 'users';

    User.login = function() {
      alert("LOGIN MODEL!");
      return console.log("LOGIN MODEL!");
    };

    return User;

  })(Batman.Model);

  /*
  #model for messages#
  contains text and user fields
  */


  Denigma.Message = (function(_super) {
    __extends(Message, _super);

    /*
    model for messages
    contains text and user fields
    */


    function Message() {
      _ref1 = Message.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Message.encode('id', 'text', 'user');

    /*
      id and two other fields to be stored: text and user
      when you make models do not forget about id
    */


    Message.validate('text', {
      presence: true
    });

    /*
      validate if text is present each time we create Message
    */


    Message.persist(Batman.SocketStorage);

    /*
      messages are stored in socket storage
    */


    Message.storageKey = 'messages';

    /*
      key for local (by the browser) storage
    */


    return Message;

  })(Batman.Model);

  /*
    #model for the task#
    contains owner, title and completed of the task
  */


  Denigma.Task = (function(_super) {
    __extends(Task, _super);

    /*
    model for the task
    contains owner, title and completed of the task
    */


    function Task() {
      _ref2 = Task.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    Task.encode('id', 'owner', 'title', 'completed');

    Task.persist(Batman.SocketStorage);

    /*
      messages are stored in socket storage
    */


    Task.validate('title', {
      presence: true
    });

    Task.storageKey = 'tasks';

    Task.classAccessor('active', function() {
      /*return all active tasks
      */
      return this.get('all').filter(function(task) {
        return !task.get('completed');
      });
    });

    Task.classAccessor('completed', function() {
      /*
        gets all tasks and than applies filter function
      */
      return this.get('all').filter(function(task) {
        return task.get('completed');
      });
    });

    Task.wrapAccessor('title', function(core) {
      return {
        set: function(key, value) {
          return core.set.call(this, key, value != null ? value.trim() : void 0);
        }
      };
    });

    return Task;

  })(Batman.Model);

  /*
  #model for search query#
  contains id and query fields
  */


  Denigma.Search = (function(_super) {
    __extends(Search, _super);

    /*
    contains id and query fields
    */


    function Search() {
      _ref3 = Search.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    Search.encode('id', 'query');

    /*
      id and two other fields to be stored: text and user
      when you make models do not forget about id
    */


    Search.persist(Batman.SocketStorage);

    /*
      searches are stored in socket storage
    */


    Search.storageKey = 'searches';

    return Search;

  })(Batman.Model);

}).call(this);

/*
//@ sourceMappingURL=models.map
*/
